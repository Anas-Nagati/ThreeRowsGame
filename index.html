<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three Rows Game</title>
    <style>
        body {
            background-color: #f7e7ea;
        }

        .title {
            font-family: 'Comic Sans MS', cursive;
            font-size: xxx-large;
            color: #ff69b4;
            margin-bottom: 30px;
        }

        .game-board {
            margin: auto;
            text-align: center;
            position: absolute;
            width: 100%;
            background: transparent;
            top: 50px;
        }

        .row {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #message {
            font-size: xx-large;
        }

        .dot {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            margin: 0 10px;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            background: linear-gradient(to bottom right, #ff9a9e, #fad0c4, #fad0c4, #ffd1ff);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .dot.selected {
            transform: scale(0.8);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .first-row .dot {
            background: linear-gradient(to bottom right, #ffdde1, #ffdde1);
        }

        .second-row .dot:nth-child(2n) {
            background: linear-gradient(to bottom right, #f6d365, #fda085);
        }

        .third-row .dot:nth-child(odd) {
            background: linear-gradient(to bottom right, #a1c4fd, #c2e9fb);
        }

        .new-game-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 16px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: xx-large;
            margin-top: 20px;
            cursor: pointer;
            border-radius: 8px;
            transition-duration: 0.4s;
        }

        .new-game-button:hover {
            background-color: #3e8e41;
        }

        .mode-buttons {
            margin-top: 20px;
        }

        .mode-button {
            background-color: #2196F3;
            border: none;
            color: white;
            padding: 12px 24px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: x-large;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 8px;
            transition-duration: 0.4s;
        }

        .mode-button:hover {
            background-color: #0b7dda;
        }

        .mode-button.active {
            background-color: #ff69b4;
        }

        .mode-button.active:hover {
            background-color: #ff1493;
        }
    </style>
</head>
<body>
<div id="particles"></div>
<div class="game-board">
    <h1 class="title">Three Rows Game</h1>
    <div class="first-row row">
        <div class="dot"></div>
    </div>
    <div class="second-row row">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
    </div>
    <div class="third-row row">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
    </div>
    <p id="message">Your turn</p>
    <div class="mode-buttons">
        <button class="mode-button" onclick="setMode(false)">2 Players</button>
        <button class="mode-button active" onclick="setMode(true)">vs AI</button>
    </div>
    <button class="new-game-button" onclick="startNewGame()">New Game</button>
</div>
<script>
    let currentPlayer = 1;
    let isAIMode = true;
    let isAIThinking = false;
    let gameOver = false;

    function hoverHandler(event) {
        if (isAIThinking || gameOver) return;

        const dot = event.target;
        const row = dot.parentNode;

        const dots = document.querySelectorAll(".dot");
        dots.forEach((d) => {
            if (d.parentNode !== row) {
                d.classList.remove("selected");
            }
        });

        const dotsInRow = [...row.querySelectorAll(".dot")];
        const currentIndex = dotsInRow.indexOf(dot);
        for (let i = 0; i <= currentIndex; i++) {
            dotsInRow[i].classList.add("selected");
        }
    }

    function clickHandler(event) {
        if (isAIThinking || gameOver) return;

        const dot = event.target;
        const row = dot.parentNode;

        const dots = document.querySelectorAll(".dot");
        dots.forEach((d) => {
            d.classList.remove("selected");
        });

        dot.classList.add("selected");

        const dotsInRow = [...row.querySelectorAll(".dot")];
        const currentIndex = dotsInRow.indexOf(dot);
        for (let i = 0; i <= currentIndex; i++) {
            if (document.querySelectorAll('.dot').length > 1) {
                dotsInRow[i].remove();
            }
        }

        // Check if game is over AFTER removing dots
        const remainingDots = document.querySelectorAll('.dot');
        if (remainingDots.length === 1) {
            gameOver = true;
            const winner = currentPlayer;
            const message = document.getElementById('message');
            if (isAIMode) {
                message.textContent = winner === 1 ? 'You WON! ðŸŽ‰' : 'AI has WON! ðŸ¤–';
            } else {
                message.textContent = `Player ${winner} has WON!`;
            }
            startConfetti();
            return;
        }

        currentPlayer = currentPlayer === 1 ? 2 : 1;
        updateMessage();

        if (isAIMode && currentPlayer === 2) {
            setTimeout(makeAIMove, 800);
        }
    }

    function updateMessage() {
        const message = document.getElementById('message');
        if (isAIMode) {
            message.textContent = currentPlayer === 1 ? "Your turn" : "AI's turn";
        } else {
            message.textContent = `Player ${currentPlayer}'s turn`;
        }
    }

    function attachEventListeners() {
        const dots = document.querySelectorAll(".dot");
        dots.forEach((dot) => {
            dot.addEventListener("mouseover", hoverHandler);
            dot.addEventListener("click", clickHandler);
        });
    }

    attachEventListeners();

    const gameBoard = document.querySelector(".game-board");
    gameBoard.addEventListener("mouseout", () => {
        const dots = document.querySelectorAll(".dot");
        dots.forEach((dot) => {
            dot.classList.remove("selected");
        });
    });

    /**
     * Find the optimal AI move using Nim strategy for misÃ¨re variant (last player loses)
     */
    function findOptimalMove(rowCounts) {
        const totalDots = rowCounts.reduce((a, b) => a + b, 0);

        // CRITICAL: If only 2 dots remain, take 1 and WIN immediately
        if (totalDots === 2) {
            for (let i = 0; i < rowCounts.length; i++) {
                if (rowCounts[i] > 0) {
                    return { rowIndex: i, dotsToRemove: Math.min(1, rowCounts[i]) };
                }
            }
        }

        // Try all possible moves and evaluate each one
        let bestMove = null;

        for (let rowIdx = 0; rowIdx < rowCounts.length; rowIdx++) {
            if (rowCounts[rowIdx] === 0) continue;

            for (let take = 1; take <= rowCounts[rowIdx]; take++) {
                // Simulate this move
                const newCounts = [...rowCounts];
                newCounts[rowIdx] -= take;

                const newTotal = newCounts.reduce((a, b) => a + b, 0);

                // Check if this move wins immediately (leaves exactly 1 dot for opponent)
                if (newTotal === 1) {
                    return { rowIndex: rowIdx, dotsToRemove: take };
                }

                // Check if this creates a known losing position for opponent
                if (isLosingPosition(newCounts)) {
                    bestMove = { rowIndex: rowIdx, dotsToRemove: take };
                    // Don't return immediately - keep looking for immediate wins
                }
            }
        }

        return bestMove;
    }

    /**
     * Check if a position is a losing position for the player to move
     * Losing positions in misÃ¨re Nim:
     * - [1] (forced to take last)
     * - [1,1] (any move leaves opponent with [1] - a win)
     * - [1,1,1] (odd number of 1s in endgame)
     * - [1,2,3]
     * - [x,x] where x > 1
     * - Any position with nim-sum = 0 in normal play, adjusted for misÃ¨re endgame
     */
    function isLosingPosition(counts) {
        const nonZero = counts.filter(c => c > 0);
        const total = counts.reduce((a, b) => a + b, 0);

        if (total === 1) return true; // Must take last dot
        if (total === 2) return false; // Can take 1 and win

        // Check for [1,1]
        if (nonZero.length === 2 && nonZero[0] === 1 && nonZero[1] === 1) {
            return true;
        }

        // Check for [1,1,1]
        if (nonZero.length === 3 && nonZero.every(c => c === 1)) {
            return true;
        }

        // Check for [1,2,3]
        const sorted = [...nonZero].sort((a, b) => a - b);
        if (sorted.length === 3 && sorted[0] === 1 && sorted[1] === 2 && sorted[2] === 3) {
            return true;
        }

        // Check for [x,x] (two equal piles)
        if (nonZero.length === 2 && nonZero[0] === nonZero[1]) {
            return true;
        }

        // Check for endgame with all piles â‰¤ 1
        const allSingletons = nonZero.every(c => c === 1);
        if (allSingletons) {
            // In endgame, odd number of piles is losing
            return nonZero.length % 2 === 1;
        }

        // For positions not in endgame, use nim-sum
        const heapsGreaterThanOne = nonZero.filter(c => c > 1);
        if (heapsGreaterThanOne.length > 0) {
            const nimSum = counts.reduce((xor, count) => xor ^ count, 0);
            return nimSum === 0;
        }

        return false;
    }

    function makeAIMove() {
        isAIThinking = true;
        const message = document.getElementById('message');
        message.textContent = "AI is thinking...";

        const rows = document.querySelectorAll('.row');
        const rowCounts = [];

        for (let i = 0; i < rows.length; i++) {
            const dots = rows[i].querySelectorAll('.dot');
            rowCounts.push(dots.length);
        }

        // Find optimal move
        let move = findOptimalMove(rowCounts);

        if (!move) {
            // No clear winning move - we're likely in a losing position
            // Make a reasonable defensive move
            const totalDots = rowCounts.reduce((a, b) => a + b, 0);

            // If we can leave exactly 1 dot, do it (opponent loses)
            for (let i = 0; i < rowCounts.length; i++) {
                if (rowCounts[i] > 0) {
                    const dotsToTake = totalDots - 1;
                    if (dotsToTake <= rowCounts[i] && dotsToTake > 0) {
                        move = { rowIndex: i, dotsToRemove: dotsToTake };
                        break;
                    }
                }
            }

            // Otherwise, take 1 from the largest pile
            if (!move) {
                let maxIdx = -1;
                let maxCount = 0;
                for (let i = 0; i < rowCounts.length; i++) {
                    if (rowCounts[i] > maxCount) {
                        maxCount = rowCounts[i];
                        maxIdx = i;
                    }
                }
                move = { rowIndex: maxIdx, dotsToRemove: 1 };
            }
        }

        const targetRow = rows[move.rowIndex];
        const dotsInRow = [...targetRow.querySelectorAll('.dot')];

        for (let i = 0; i < move.dotsToRemove; i++) {
            if (dotsInRow[i] && document.querySelectorAll('.dot').length > 1) {
                dotsInRow[i].remove();
            }
        }

        isAIThinking = false;

        // Check if game is over
        const remainingDots = document.querySelectorAll('.dot');
        if (remainingDots.length === 1) {
            gameOver = true;
            const message = document.getElementById('message');
            message.textContent = 'AI has WON! ðŸ¤–';
            startConfetti();
            return;
        }

        currentPlayer = 1;
        updateMessage();
    }

    function startNewGame() {
        if (typeof stopConfetti === 'function') {
            stopConfetti();
        }
        isAIThinking = false;
        gameOver = false;

        const firstRow = document.querySelector('.first-row');
        const secondRow = document.querySelector('.second-row');
        const thirdRow = document.querySelector('.third-row');

        firstRow.innerHTML = '<div class="dot"></div>';
        secondRow.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>';
        thirdRow.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div><div class="dot"></div>';

        attachEventListeners();

        currentPlayer = 1;
        updateMessage();
    }

    function setMode(aiMode) {
        isAIMode = aiMode;

        const buttons = document.querySelectorAll('.mode-button');
        buttons.forEach((btn, index) => {
            if ((index === 1 && aiMode) || (index === 0 && !aiMode)) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        startNewGame();
    }
</script>
</body>
</html>
